---
title: Tests
inMenu: true
orderInfo: 30
---
h2. Tests

Tests are modules of Inquisitor that do the real work. They usually do
one specific action and can return binary result: passed or failed.
Tests are usually ran automatically by
<a href="{relocatable: scheduler.page}">scheduler</a>, but can be
<a href="{relocatable: manual-invocation.page}">invoked manually</a>,
as a regular executable with parameters. All tests follow the
same format (which is described in
<a href="{relocatable: test-format.page}">test format</a> section).

Current version of Inquisitor includes the following tests:

<table class="toc">
<tr><th>#</th><th>Script</th><th>Title</th><th>Components tested</th></tr>
<tr><td style="text-align: right">1</td><td>bonnie</td><td><a href="#bonnie">Bonnie</a></td><td>HDD</td></tr>
<tr><td style="text-align: right">2</td><td>bytemark</td><td><a href="#bytemark">BYTEmark</a></td><td>CPU, Memory, Mainboard</td></tr>
<tr><td style="text-align: right">3</td><td>cpu</td><td><a href="#cpu">CPU burn</a></td><td>CPU</td></tr>
<tr><td style="text-align: right">4</td><td>db_comparison</td><td><a href="#db_comparison">DB to Detects comparison</a></td><td>BMC, CPU, Chassis, Disk Controller, Floppy, HDD, Mainboard, Memory, NIC, OSD, Platform, USB, Video</td></tr>
<tr><td style="text-align: right">5</td><td>dhrystone</td><td><a href="#dhrystone">Dhrystone</a></td><td>CPU</td></tr>
<tr><td style="text-align: right">6</td><td>fdd</td><td><a href="#fdd">FDD read/write</a></td><td>Floppy</td></tr>
<tr><td style="text-align: right">7</td><td>firmware</td><td><a href="#firmware">Firmware reflashing</a></td><td>Mainboard, Disk Controller</td></tr>
<tr><td style="text-align: right">8</td><td>flash</td><td><a href="#flash">Flash disk</a></td><td></td></tr>
<tr><td style="text-align: right">9</td><td>gprs-modem</td><td><a href="#gprs-modem">USB GPRS modem</a></td><td></td></tr>
<tr><td style="text-align: right">10</td><td>gprs-modem-dialup</td><td><a href="#gprs-modem-dialup">USB GPRS Modem Dialup</a></td><td></td></tr>
<tr><td style="text-align: right">11</td><td>gprs-modem-level</td><td><a href="#gprs-modem-level">USB GPRS modem signal level</a></td><td></td></tr>
<tr><td style="text-align: right">12</td><td>hdd-array</td><td><a href="#hdd-array">HDD array stress</a></td><td>CPU, HDD, Memory, Mainboard, Disk Controller</td></tr>
<tr><td style="text-align: right">13</td><td>hdd-passthrough</td><td><a href="#hdd-passthrough">HDD passthrough</a></td><td>CPU, HDD, Memory, Mainboard, Disk Controller</td></tr>
<tr><td style="text-align: right">14</td><td>hdparm</td><td><a href="#hdparm">HDD speed benchmark: hdparm</a></td><td>Disk Controller, HDD</td></tr>
<tr><td style="text-align: right">15</td><td>memory</td><td><a href="#memory">Memory test: memtester</a></td><td>Memory</td></tr>
<tr><td style="text-align: right">16</td><td>mencoder</td><td><a href="#mencoder">Mencoder</a></td><td>CPU, Memory, Mainboard</td></tr>
<tr><td style="text-align: right">17</td><td>net</td><td><a href="#net">Network interface</a></td><td>NIC</td></tr>
<tr><td style="text-align: right">18</td><td>odd_read</td><td><a href="#odd_read">ODD read</a></td><td>ODD</td></tr>
<tr><td style="text-align: right">19</td><td>odd_write</td><td><a href="#odd_write">odd_write</a></td><td>ODD</td></tr>
<tr><td style="text-align: right">20</td><td>stream</td><td><a href="#stream">Stream</a></td><td>Memory</td></tr>
<tr><td style="text-align: right">21</td><td>unixbench</td><td><a href="#unixbench">Unixbench</a></td><td>CPU, Memory, Mainboard</td></tr>
<tr><td style="text-align: right">22</td><td>usb-device</td><td><a href="#usb-device">USB presence</a></td><td>USB</td></tr>
<tr><td style="text-align: right">23</td><td>usb-flash-drive</td><td><a href="#usb-flash-drive">USB Flash Drive</a></td><td>USB</td></tr>
<tr><td style="text-align: right">24</td><td>whetstone</td><td><a href="#whetstone">Whetstone</a></td><td>CPU</td></tr>
</table>

h3. <a name="bonnie"></a>Bonnie (bonnie)

<div class="infobox"><img src="{relocatable:/images/hdd-destructive.png}" width="64" height="64" title="Test destroys contents of HDD" alt="Test destroys contents of HDD" /></div>

This test uses bonnie++ benchmark to test hard drives performance. For every hard drive in a system, test formats it using ext2 filesystem and then runs bonnie++ benchmark. Test measures the IO throughput in situations that simulate some types of database applications. It uses a single test file size to twice the amount of RAM. Benchmark reports output/rewrite/input of char/block speed and CPU load.

* *Components tested:* HDD

h3. <a name="bytemark"></a>BYTEmark (bytemark)


BYTEmark native mode benchmark

* *Components tested:* CPU, Memory, Mainboard

h3. <a name="cpu"></a>CPU burn (cpu)


Basic CPU burn test makes the CPUs execute instructions that rapidly increase processor's temperature in an infinite loop. Test makes special care about used instruction set (to make load as high as possible).

* *Components tested:* CPU
* *Variables:*
** *TESTTIME* (int, default: @1800@) &mdash; Total time of CPU testing, sec

h3. <a name="db_comparison"></a>DB to Detects comparison (db_comparison)


Pauses testing until comparison has been completed on the application server.

* *Components tested:* BMC, CPU, Chassis, Disk Controller, Floppy, HDD, Mainboard, Memory, NIC, OSD, Platform, USB, Video

h3. <a name="dhrystone"></a>Dhrystone (dhrystone)


A synthetic computing benchmark that measures CPU integer performance. Inquisitor uses a C version and runs the specified number of loops, testing each CPU separately, with testing process running affined to particular CPU. Performance rating is in terms of MIPS.

* *Components tested:* CPU
* *Variables:*
** *DURATION* (int, default: @30@) &mdash; Benchmark duration (sec)

h3. <a name="fdd"></a>FDD read/write (fdd)


A simple test to determine wheter the floppy drive work or not. It asks a user to insert a floppy disk into drive, then writes some random data on a diskette, clears the cache, reads the data back and compares it to what was written. Process repeats for every FDD available.

* *Components tested:* Floppy
* *Variables:*
** *FLOPPY_SIZE* (int, default: @1440@) &mdash; Size of testing floppy, KiB

h3. <a name="firmware"></a>Firmware reflashing (firmware)


Firmware reflashing

* *Components tested:* Mainboard, Disk Controller

h3. <a name="flash"></a>Flash disk (flash)

<div class="infobox"><img src="{relocatable:/images/hdd-destructive.png}" width="64" height="64" title="Test destroys contents of HDD" alt="Test destroys contents of HDD" /></div>

Flash disk badblocks test

* *Variables:*
** *SIZE_LIMIT* (int, default: @2048@) &mdash; That is less than this amount is an IDE flash, MiB

h3. <a name="gprs-modem"></a>USB GPRS modem (gprs-modem)


Test GPRS modem, connected using USB

* *Variables:*
** *ANSWER_ATI* (string, default: @OK@) &mdash; String to get after ATI
** *CHAT_TIMEOUT* (int, default: @5@) &mdash; Timeout for waiting for answer
** *DEV* (string, default: @/dev/ttyUSB0@) &mdash; Name of device to test

h3. <a name="gprs-modem-dialup"></a>USB GPRS Modem Dialup (gprs-modem-dialup)


Test GPRS modem, connected using USB

* *Variables:*
** *APN* (string, default: @internet.mts.ru@) &mdash; Cell service provider's Internet APN
** *DEV* (string, default: @/dev/ttyUSB0@) &mdash; Name of device to test
** *DOWNLOAD_MAX_TIME* (int, default: @60@) &mdash; Timeout for the whole download, sec
** *DOWNLOAD_TRIES* (int, default: @3@) &mdash; Number of tries to download the file
** *MD5* (string, default: @ca530886183b06d0047e0655537327aa@) &mdash; MD5 of downloaded file
** *PPPD_TRIES* (int, default: @4@) &mdash; Number of tries to bring pppd up
** *PPPD_USERNAME* (string, default: @mts@) &mdash; Cell service provider's pppd username
** *SPEED* (int, default: @115200@) &mdash; Line speed
** *UPLOAD_FILE* (string, default: @/etc/ld.so.cache@) &mdash; File to upload
** *UPLOAD_MAX_TIME* (int, default: @120@) &mdash; Timeout for file upload, sec
** *UPLOAD_TRIES* (int, default: @3@) &mdash; Number of tries to upload the file
** *UPLOAD_URL* (string, default: _empty_) &mdash; URL to upload (without http)
** *URL* (string, default: @img-fotki.yandex.ru/getx/10/photoface.359/sevastopol-foto_34661_L@) &mdash; URL to download (without http)

h3. <a name="gprs-modem-level"></a>USB GPRS modem signal level (gprs-modem-level)


Measure signal level, received by GPRS modem, connected via USB

* *Variables:*
** *CHAT_TIMEOUT* (int, default: @5@) &mdash; Timeout for waiting for answer
** *DEV* (string, default: @/dev/ttyUSB0@) &mdash; Name of device to test

h3. <a name="hdd-array"></a>HDD array stress (hdd-array)

<div class="infobox"><img src="{relocatable:/images/hdd-destructive.png}" width="64" height="64" title="Test destroys contents of HDD" alt="Test destroys contents of HDD" /></div>

HDD array is a stress test that causes high load on HDD array subsystem. First of all, it creates optimally configured arrays (if possible, otherwise it will use single hard drives) using einarc's raid-wizard-optimal utility. Then it creates a filesystem on each array and unpacks and compiles there a large source tree for a specified time. Test distributes specified test duration among created arrays equally. Compilation, as in hdd-passthrough test, goes with 16 simultaneous jobs (by default). Test would end successfully if there wouldn't be any errors in filesystem creation and source code compilation runs. Usually this test starts after the CPU burning, memory and hdd-passthrough ones, and thus failing of this test (considering successful previous tests) usually identifies a broken RAID controller.

* *Components tested:* CPU, HDD, Memory, Mainboard, Disk Controller
* *Variables:*
** *JOBS* (int, default: @16@) &mdash; Number of parallely running jobs during compile
** *LOGTIME* (int, default: @120@) &mdash; Time between progress updates, sec
** *STRESS_TREE* (string, default: @linux-2.6.22.5-31-stress.tar.gz@) &mdash; Tarball file containing stress test tree
** *TESTTIME* (int, default: @3600@) &mdash; Total time of HDD array testing, sec

h3. <a name="hdd-passthrough"></a>HDD passthrough (hdd-passthrough)

<div class="infobox"><img src="{relocatable:/images/hdd-destructive.png}" width="64" height="64" title="Test destroys contents of HDD" alt="Test destroys contents of HDD" /></div>

HDD passthrough is a stress test that imposes heavy load on main system components. First, it tries to make all HDDs present in the system to appear as separate device nodes - it checks all available RAID controllers, deletes all arrays / disk groups and creates passthrough devices to access individual HDDs if required. Second, it runs badblocks test on every available HDD, running them simulatenously in groups of 8 HDDs by default. Third, it makes a ramdisk filesystem and starts infinite compilation loop in memory, doing so with 16 simultaneous jobs (by default). Test ends successfully after both 1) minimal required stress time passes, 2) all HDDs are checked with badblocks. Test would fail if any bad blocks would be detected on any HDD. Test will usually hang or crash the system on the unstable hardware.

* *Components tested:* CPU, HDD, Memory, Mainboard, Disk Controller
* *Variables:*
** *DISK_GROUP_SIZE* (int, default: @8@) &mdash; Number of disks per group for testing
** *JOBS* (int, default: @16@) &mdash; Number of parallely running jobs during stress test tree compile
** *MINIMAL_STRESS_TIME* (int, default: @600@) &mdash; Minimal time of stress testing
** *RAMDISK_SIZE* (int, default: @400@) &mdash; Size of memory disk for stress tree building, MB
** *STRESS_TREE* (string, default: @linux-2.6.22.5-31-stress.tar.gz@) &mdash; Tarball file containing stress test tree

h3. <a name="hdparm"></a>HDD speed benchmark: hdparm (hdparm)


This benchmark runs on all hard drives in the system sequentially. Every hard drive is benchmarked for the buffered speed and the cached speed using basic hdparm -t and -T tests for several times. The results for every HDD are averaged and presented as benchmark results.

* *Components tested:* Disk Controller, HDD
* *Variables:*
** *AVG_SAMPLES* (int, default: @5@) &mdash; Number of tests per disc to average for result

h3. <a name="memory"></a>Memory test: memtester (memory)


This memory test is performed without reboot, under control of live full-featured OS, using user-space memtester program. Test takes special precautions and tries to lock maximum possible amount of memory for memtester. memtester tests memory using standard read-write-check method using 16 patterns.

* *Components tested:* Memory
* *Variables:*
** *LOGTIME* (int, default: @120@) &mdash; Time between progress updates, sec
** *TEST_LOOPS* (int, default: @3@) &mdash; Number of testing loops

h3. <a name="mencoder"></a>Mencoder (mencoder)


Mencoder encoding time benchmark

* *Components tested:* CPU, Memory, Mainboard
* *Variables:*
** *ENCODE_OPTIONS* (string, default: @-ovc lavc -lavcopts vcodec=mpeg4 -oac mp3lame -lameopts vbr=3@) &mdash; Encoding options
** *FILE_TO_ENCODE* (string, default: @/usr/share/inquisitor/movie.avi@) &mdash; Path to file need to be encoded

h3. <a name="net"></a>Network interface (net)


This test must load every network interface in system and measure it's download speed. Main requirement: all network interfaces must be connected to one common network. Testing sequence is: 1) Detect and remember what interface is default (from what we are booted up (as common)); 2) Consecutively choosing each interface, check if it's MAC address doesn't exist in "exclude macs" test parameter, then either skip it, continuing with another one, or continue to test current inteface; 3) Bring testing interface up, configuring network on it and setting it as a default gateway; 4) Bring down all other interfaces; 5) Get test file from specified URL, measuring download speed; 6) Calculate it's checksum and compare with needed (specified by test parameter). Here, test can fail if an error occurs, otherwise it submits speed benchmarking result and continues to test remaining interfaces; 7) After all interfaces (except the first one) are tested, default interface starts testing: there is no real need in it, when we are booting from network - but it is a simplest way to restore default parameters.

* *Components tested:* NIC
* *Variables:*
** *EXCLUDE_MAC* (string, default: _empty_) &mdash; Exclude NICs with MAC addresses that match this regexp from testing
** *MD5* (string, default: @805414334eb1d3ff4fdca507ec82098f@) &mdash; MD5 checksum for checking
** *TIMEOUT* (int, default: @15@) &mdash; Wait timeout while test file retrieving, sec
** *URL* (string, default: @3000/test_file@) &mdash; Relative to server PORT:URL to be fetched and checked

h3. <a name="odd_read"></a>ODD read (odd_read)


Optical Disc Drive read test

* *Components tested:* ODD
* *Variables:*
** *FORCE_NON_INTERACTIVE* (boolean, default: @false@) &mdash; Force non-interactive mode for already prepared system
** *MESH_POINTS* (int, default: @1024@) &mdash; Points for meshes for monitoring drive's speed
** *TEST_IMAGE_BLOCKS* (int, default: @332800@) &mdash; This images size in blocks (2048 bytes each)
** *TEST_IMAGE_HASH* (string, default: @6fa7786eef2e11d36e8bc1663679f161@) &mdash; Default image for comparison hash

h3. <a name="odd_write"></a>odd_write (odd_write)


Optical Disc Drive write test

* *Components tested:* ODD
* *Variables:*
** *FORCE_NON_INTERACTIVE* (boolean, default: @false@) &mdash; Force non-interactive mode for already prepared system
** *TEST_IMAGE* (string, default: @iso/testimage.iso@) &mdash; ISO image path (absolute or relative)
** *TEST_IMAGE_BLOCKS* (int, default: @332800@) &mdash; This images size in blocks (2048 bytes each)
** *TEST_IMAGE_MD5* (string, default: @ffffffffffffffffffffffffffffffff@) &mdash; Test image MD5 hash
** *WRITE_MESSAGE* (string, default: @Writing test disc@) &mdash; Message to print when test will start
** *WRITE_SPEED* (int, default: @10@) &mdash; Default write speed if it won't detect
** *WRITE_SPEED_FORCE* (boolean, default: @true@) &mdash; Force write speed using

h3. <a name="stream"></a>Stream (stream)


The STREAM benchmark is a simple synthetic benchmark program that measures sustainable memory bandwidth (in MiB/s) and the corresponding computation rate for simple vector kernels. A version written in C language and optimized for single processor systems is used.

* *Components tested:* Memory

h3. <a name="unixbench"></a>Unixbench (unixbench)


UNIX Bench Multi-CPU benchmark

* *Components tested:* CPU, Memory, Mainboard

h3. <a name="usb-device"></a>USB presence (usb-device)


Tests the presence of designated USB devices. It checks for a count of USB devices that match specified idVendor and idProduct and gives a success if they're equal to COUNT parameter or failure if they're not.

* *Components tested:* USB
* *Variables:*
** *COUNT* (int, default: @1@) &mdash; There should be this many devices
** *IDPRODUCT* (string, default: @6001@) &mdash; Filter in only devices with this idProduct (match all if empty)
** *IDVENDOR* (string, default: @0403@) &mdash; Filter in only devices with this idVendor (match all if empty)

h3. <a name="usb-flash-drive"></a>USB Flash Drive (usb-flash-drive)

<div class="infobox"><img src="{relocatable:/images/hdd-destructive.png}" width="64" height="64" title="Test destroys contents of HDD" alt="Test destroys contents of HDD" /></div>

This test allows to check the working ability of USB ports and/or plugged USB storage devices. A user has to plug the USB storage devices (such as USB flash drives) in every USB port of system under test. A number of USB storage drives is passed then as a COUNT parameter to this test script. First of all, it checks if a required number of USB devices is plugged in: the test won't start if it's not so. This way, a non-working USB port would be diagnosed. The test itself does the following for every detected USB storage device: it writes a number of blocks wit random data (start position is choosen randomly to increase an USB drive's lifetime) and remembers their checksum, then it clears the disk cache and reads these blocks back, calculating checksum. If checksums match, USB device and port work properly. This test also acts as a benchmark: it measures write and read speeds. This metric can be used  to diagnose bad ports/USB devices (due to speed lower than required minimum).

* *Components tested:* USB
* *Variables:*
** *BLOCKSIZE* (int, default: @1024@) &mdash; Blocksize used for reading and writing by dd, KiB
** *COUNT* (int, default: @2@) &mdash; There should be this many devices
** *SIZE* (int, default: @20@) &mdash; Size of test file to be written, Blocksizes

h3. <a name="whetstone"></a>Whetstone (whetstone)


A synthetic computing benchmark that measures CPU floating-point performance. Inquisitor uses a C version and runs the specified number of loops, testing each CPU separately, with testing process running affined to particular CPU. Performance rating is in terms of MIPS.

* *Components tested:* CPU
* *Variables:*
** *LOOPS* (int, default: @20000@) &mdash; Loop count

