#!/usr/bin/env ruby

require 'rbconfig'
RbConfig = Config unless defined?(RbConfig)

require 'optparse'

#===============================================================================
# A detailed list of modules that are supported in this version of Einarc
#===============================================================================

RAIDS = {
	'areca' => {
		:desc => 'Areca adapters',
		:classname => 'Areca',
		:proprietary => true,
	},
	'lsi_megarc' => {
		:desc => 'older LSI MegaRAID SCSI/SATA adapters',
		:classname => 'LSIMegaRc',
		:proprietary => true,
	},
#	'lsi_mpt' => {
#		:desc => 'LSI MPT HBA adapters',
#		:classname => 'LSIMPT',
#		:proprietary => false,
#	},
	'lsi_megacli' => {
		:desc => 'newest LSI MegaRAID SAS adapters',
		:classname => 'LSIMegaCli',
		:proprietary => true,
	},
	'adaptec_aaccli' => {
		:desc => 'older Adaptec SCSI adapters that use aaccli',
		:classname => 'AdaptecAacCli',
		:proprietary => true,
	},
	'adaptec_arcconf' => {
		:desc => 'newer Adaptec adapters that use arcconf',
		:classname => 'AdaptecArcConf',
		:proprietary => true,
	},
	'amcc' => {
		:desc => '3Ware/AMCC RAID 7/8/9xxx/95xxx series controllers that use tw_cli',
		:classname => 'Amcc',
		:proprietary => true,
	}
#	'software' => {
#		:desc => 'Linux software RAID devices',
#		:classname => 'Software',
#		:proprietary => false,
#	}
}

#===============================================================================
# Initialize options from environment and with detected defaults
#===============================================================================

options = {
	'BIN_DIR' => ENV['BIN_DIR'] || '/usr/local/bin',
	'RUBY_SHARE_DIR' => (ENV['RUBY_SHARE_DIR'] || RbConfig::CONFIG['sitelibdir']) + '/raid',
	'RUBY_LIB_DIR' => (ENV['RUBY_LIB_DIR'] || (RbConfig::CONFIG['vendorarchdir'] ? RbConfig::CONFIG['vendorarchdir'] : RbConfig::CONFIG['archdir'])) + '/raid',
	'LIB_DIR' => ENV['LIB_DIR'] || '/usr/local/lib',
	'TARGET' => ENV['TARGET'] || `uname -m`.chomp,
}
options['EINARC_LIB_DIR'] = (ENV['EINARC_LIB_DIR'] || options['LIB_DIR']) + '/einarc'
options['modules'] = RAIDS.keys

#===============================================================================
# Parse command-line
#===============================================================================

begin
	OptionParser.new { |opts|
		opts.banner = 'Usage: ./configure [OPTION]...'

		padding = "\n" + opts.summary_indent + ' ' * (opts.summary_width + 3)
		module_help = padding + 'all - SPECIAL: build all available modules'
		RAIDS.each_pair { |k, v| module_help += "#{padding}#{k} - #{v[:desc]}" }

		opts.on('--target=TARGET', "target to build for [#{options['TARGET']}]") { |t| options['TARGET'] = t }
		opts.on('--bindir=DIR', "user executables [#{options['BIN_DIR']}]") { |d| options['BIN_DIR'] = d }
		opts.on('--rubysharedir=DIR', "ruby share directory [#{options['RUBY_SHARE_DIR']}]") { |d| options['RUBY_SHARE_DIR'] = d }
		opts.on('--rubylibdir=DIR', "ruby binary extensions directory [#{options['RUBY_LIB_DIR']}]") { |d| options['RUBY_LIB_DIR'] = d }
		opts.on('--einarclibdir=DIR', "proprietary extensions directory [#{options['EINARC_LIB_DIR']}]") { |d| options['EINARC_LIB_DIR'] = d }
		opts.on('--modules=LIST', "a comma-separated list of storage support modules to build [all]:#{module_help}") { |d|
			options['modules'] = d.split(/, */) unless d == 'all'
			options['modules'].each { |m| raise OptionParser::InvalidArgument unless RAIDS[m] }
		}
		opts.on_tail('-h', '--help', 'Show this message') { puts opts; exit }
	}.parse!
	raise OptionParser::ParseError.new("Can't parse extra arguments in command line: #{ARGV.join(' ')}") unless ARGV.empty?
rescue OptionParser::ParseError => e
	$stderr.puts e.message
	exit 1
end

#===============================================================================
# Output results
#===============================================================================


File.open('Makefile.config', 'w') { |f|
	f.puts <<__EOF__
# DO NOT EDIT: IT'S A GENERATED FILE! USE ./configure to REGENERATE!

BIN_DIR=#{options['BIN_DIR']}
RUBY_SHARE_DIR=#{options['RUBY_SHARE_DIR']}
RUBY_LIB_DIR=#{options['RUBY_LIB_DIR']}
EINARC_LIB_DIR=#{options['EINARC_LIB_DIR']}
TARGET=#{options['TARGET']}

# Modules to build: #{options['modules'].join(', ')}

tools: \\
#{options['modules'].collect { |m| "\ttools/#{m}/cli" if RAIDS[m][:proprietary] }.compact.join(" \\\n")}
__EOF__
}

File.open('src/raid/config.rb', 'w') { |f|
	f.puts <<__EOF__
# DO NOT EDIT: IT'S A GENERATED FILE! USE ./configure to REGENERATE!

module RAID
	$EINARC_LIB = '#{options['EINARC_LIB_DIR']}'

#{options['modules'].collect { |m| "\trequire 'raid/#{m}'" }.join("\n")}

	RAIDS = {
#{options['modules'].collect { |m| "\t\t'#{m}' => #{RAIDS[m][:classname]}," }.join("\n")}
	}
end
__EOF__
}

#===============================================================================
# Report success
#===============================================================================

puts <<__EOF__
Configure succeeded! 

Directories
-----------
User executables:       #{options['BIN_DIR']}
Ruby share:             #{options['RUBY_SHARE_DIR']}
Ruby libraries:         #{options['RUBY_LIB_DIR']}
Proprietary extensions: #{options['EINARC_LIB_DIR']}

Modules
-------
#{options['modules'].join("\n")}

Now run 'make' to build Einarc and 'make install' to install it.
__EOF__
