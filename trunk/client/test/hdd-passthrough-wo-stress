#!/bin/sh -e
# NAME=HDD passthrough without compiling kernel sources
# DESCRIPTION=Test based on hdd-passthrough, but it is not compile sources
# DESTROYS_HDD=true
# IS_INTERACTIVE=false
# POWEROFF_DURING_TEST=false
# VERSION=0.2
# TAGS=hdd,stress
# DEPENDS=CPU,HDD,Memory,Mainboard,Disk Controller
# VAR=DISK_GROUP_SIZE:int:8:Number of disks per group for testing
# VAR=MINIMAL_STRESS_TIME:int:600:Minimal time of stress testing
# VAR=STRESS_TREE:string:linux-2.6.22.5-31-stress.tar.gz:Tarball file containing stress test tree
# VAR=RAMDISK_SIZE:int:400:Size of memory disk for stress tree building, MB
# VAR=JOBS:int:16:Number of parallely running jobs during stress test tree compile

. global; . $SHARE_DIR/functions-test

exit_handler()
{
	sleep 5
	if [ -d "$MOUNTPOINT" ]; then
		cd $HOME/
		umount -f $MOUNTPOINT >/dev/null 2>&1 || true
		rmdir $MOUNTPOINT
	fi
	[ -f "$ERROR_FILE" ] && rm $ERROR_FILE
}

MOUNTPOINT=`mktemp -d`
export ERROR_FILE=`mktemp`

# Checking if this machince has too low amount of memory
if [ "`memory_amount`" -lt 600 ]; then
	RAMDISK_SIZE=300
	MAKE_ARGS="fs"
	JOBS=4
else
	MAKE_ARGS="all"
fi

badblocks_test()
{
	raid-wizard-clear || echo "raid-wizard-clear failed" > "$ERROR_FILE"
	sleep 10 # We have to use such dirty hack, because einarc's
	         # operations are not waiting for real commands
		 # completion. So, for example, we can get hard drives
		 # appearing for kernel (in dmesg) during several
		 # seconds.
	$SHARE_DIR/hdd-badblocks.rb `get_hdds_list` ||
		echo "hdd-badblocks.rb failed" > "$ERROR_FILE"

	I=0
	while raid-wizard-passthrough $DISK_GROUP_SIZE $I; do
		sleep 10 # Dirty hack again
		$SHARE_DIR/hdd-badblocks.rb `get_hdds_list` ||
			echo "hdd-badblocks.rb #$i failed" > "$ERROR_FILE"
		I=$(( $I + 1 ))
	done

	current_time=`date "+%s"`
	if [ $(( $current_time - $START_TIME )) -lt "$MINIMAL_STRESS_TIME" ]; then
		sleep $(( $MINIMAL_STRESS_TIME - ($current_time - $START_TIME) ))
	else
		true
	fi
}

START_TIME=`date "+%s"`

# Run badblocks and compilation processes simultaneously
badblocks_test &
BADBLOCKS_PID=$!

# Wait their completion and check if there are any errors
wait || true
[ -s "$ERROR_FILE" ] && test_failed "`sed -n '1p' <$ERROR_FILE`" || test_succeeded

